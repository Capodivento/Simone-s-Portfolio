<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Immersive Wave Field Experience</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            /* No background color - handled by Three.js */
        }
        canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            opacity: 0.8;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        .info {
            font-size: 14px;
        }
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            color: white;
            display: flex;
            flex-direction: column;
            gap: 15px;
            backdrop-filter: blur(10px);
            max-height: calc(100vh - 40px); /* Max height for controls */
            overflow-y: auto; /* Allow scrolling for controls if too many */
            z-index: 10;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 12px;
            opacity: 0.9;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        button.active { /* Style for active mode button */
            background: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }
        .reset-btn {
            margin-top: 10px;
        }
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .audio-btn {
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .audio-icon {
            width: 16px;
            height: 16px;
            fill: white;
        }
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a2a6c 0%, #3080ab 50%, #803aac 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
            transition: opacity 0.8s ease-out;
        }
        .loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            margin-top: 20px;
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #6abbff, #ff78d7);
            transition: width 0.2s;
        }
        .fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="loading-screen">
        <h2>Wave Field Experience</h2>
        <p>Preparing your immersive experience...</p>
        <div class="loading-progress">
            <div class="progress-bar"></div>
        </div>
    </div>

    <div class="overlay">
        <div class="info">Move your mouse/touch to interact with the wave field</div>
        <div class="info">Current mode: <span id="mode-display">Wave</span></div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="wave-intensity">Wave Intensity</label>
            <input type="range" id="wave-intensity" min="0.1" max="2.0" step="0.1" value="0.4">
        </div>
        <div class="control-group">
            <label for="particle-size">Particle Size</label>
            <input type="range" id="particle-size" min="0.005" max="0.1" step="0.001" value="0.02">
        </div>
        <div class="control-group">
            <label for="color-speed">Color Shift Speed</label>
            <input type="range" id="color-speed" min="0.0001" max="0.005" step="0.0001" value="0.001">
        </div>
        <div class="control-group">
            <label for="camera-motion">Camera Motion</label>
            <input type="range" id="camera-motion" min="0" max="1" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Wave Mode</label>
            <div style="display: flex; gap: 8px;">
                <button id="mode-wave" class="mode-btn active">Wave</button>
                <button id="mode-ripple" class="mode-btn">Ripple</button>
                <button id="mode-fractals" class="mode-btn">Fractals</button>
            </div>
        </div>
        <div class="audio-controls">
            <button id="audio-toggle" class="audio-btn">
                <svg class="audio-icon" viewBox="0 0 24 24">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
            </button>
            <input type="range" id="audio-volume" min="0" max="1" step="0.05" value="0.5">
        </div>
        <button id="reset-btn" class="reset-btn">Reset Settings</button>
    </div>

    <button id="fullscreen-btn" class="fullscreen-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
        </svg>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Initialize loading manager
        const loadingManager = new THREE.LoadingManager();
        const progressBar = document.querySelector('.progress-bar');
        const loadingScreen = document.querySelector('.loading-screen');

        loadingManager.onStart = function (url, itemsLoaded, itemsTotal) {
            // console.log('Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
        };

        loadingManager.onProgress = function(url, loaded, total) {
            progressBar.style.width = (loaded / total * 100) + '%';
        };

        loadingManager.onLoad = function() {
            progressBar.style.width = '100%';
            setTimeout(function() {
                loadingScreen.style.opacity = 0;
                setTimeout(function() {
                    loadingScreen.style.display = 'none';
                }, 800); // Match CSS transition duration
            }, 500); // Small delay before fading
        };

        loadingManager.onError = function (url) {
            console.error('There was an error loading ' + url);
        };


        // Configuration
        const DEFAULT_CONFIG = {
            GRID_SIZE: 100, // Number of particles along one axis
            SPACING: 0.3,   // Spacing between particles
            WAVE_SPEED: 0.4,
            WAVE_INTENSITY: 0.4,
            MOUSE_INFLUENCE: 15, // How much mouse/touch affects waves
            PARTICLE_SIZE: 0.02,
            COLOR_SHIFT_SPEED: 0.001,
            USE_INSTANCING: true,
            CAMERA_MOTION_INTENSITY: 1.0,
            WAVE_MODE: 'wave',  // 'wave', 'ripple', 'fractals'
            AUDIO_ENABLED: false,
            AUDIO_VOLUME: 0.5
        };
        let CONFIG = { ...DEFAULT_CONFIG };


        // Audio context and elements
        let audioContext, gainNode, oscillator;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.gain.value = 0; // Start muted
                gainNode.connect(audioContext.destination);
                
                createAmbientSound();
                
                CONFIG.AUDIO_ENABLED = false; // Ensure it's off initially
                updateAudioButton();
            } catch (e) {
                console.error("Web Audio API is not supported in this browser");
                const audioControls = document.querySelector('.audio-controls');
                if(audioControls) audioControls.style.display = 'none'; 
            }
        }
        
        function createAmbientSound() {
            if (!audioContext) return;
            const lfo = audioContext.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.1; 
            
            const lfoGain = audioContext.createGain();
            lfoGain.gain.value = 20; 
            
            lfo.connect(lfoGain);
            
            oscillator = audioContext.createOscillator();
            oscillator.type = 'sine'; 
            oscillator.frequency.value = 65; 
            
            lfoGain.connect(oscillator.frequency);
            
            const convolver = audioContext.createConvolver();
            createImpulseResponse(audioContext, 2, 3, false).then(buffer => {
                if (!audioContext || audioContext.state === 'closed') return; 
                convolver.buffer = buffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800; 
                
                oscillator.connect(filter);
                filter.connect(convolver);
                convolver.connect(gainNode); 
                
                if (oscillator.context.state !== 'closed') { // Check before starting
                    lfo.start();
                    oscillator.start();
                }
            }).catch(err => console.error("Error creating impulse response: ", err));
        }
        
        function createImpulseResponse(audioCtx, duration, decay, reverse) {
            return new Promise((resolve, reject) => {
                if (!audioCtx || audioCtx.state === 'closed') {
                     reject(new Error("AudioContext is closed."));
                     return;
                }
                const sampleRate = audioCtx.sampleRate;
                const length = sampleRate * duration;
                const impulse = audioCtx.createBuffer(2, length, sampleRate); 
                const impulseL = impulse.getChannelData(0);
                const impulseR = impulse.getChannelData(1);
                
                for (let i = 0; i < length; i++) {
                    const n = reverse ? length - i : i;
                    impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
                    impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
                }
                
                resolve(impulse);
            });
        }
        
        function updateAudioButton() {
            const audioToggle = document.getElementById('audio-toggle');
            if (!audioToggle) return;
            const audioIcon = audioToggle.querySelector('.audio-icon');
            
            if (CONFIG.AUDIO_ENABLED) {
                audioIcon.innerHTML = `<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>`;
                if (gainNode && audioContext) {
                   if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    gainNode.gain.setTargetAtTime(CONFIG.AUDIO_VOLUME, audioContext.currentTime, 0.2);
                }
            } else {
                audioIcon.innerHTML = `<path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>`;
                if (gainNode && audioContext) {
                    gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.2);
                }
            }
        }

        // Initialize SimplexNoise for fractal mode
        const simplex = new SimplexNoise();

        // Create immersive environment
        function createEnvironment() {
            const skyGeometry = new THREE.SphereGeometry(1000, 48, 48);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    topColor: { value: new THREE.Color(0x1a2a6c) },
                    middleColor: { value: new THREE.Color(0x3080ab) },
                    bottomColor: { value: new THREE.Color(0x803aac) },
                    cloudColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 topColor;
                    uniform vec3 middleColor;
                    uniform vec3 bottomColor;
                    uniform vec3 cloudColor;
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    
                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        float a = sin(dot(i, vec2(12.9898, 78.233))) * 43758.5453;
                        float b = sin(dot(i + vec2(1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453;
                        float c = sin(dot(i + vec2(0.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453;
                        float d = sin(dot(i + vec2(1.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453;
                        return mix(mix(sin(a), sin(b), u.x), mix(sin(c), sin(d), u.x), u.y) * 0.5 + 0.5;
                    }
                    
                    float fbm(vec2 p) {
                        float sum = 0.0;
                        float amp = 0.5;
                        float freq = 1.0;
                        for(int i = 0; i < 6; i++) {
                            sum += noise(p * freq) * amp;
                            amp *= 0.5;
                            freq *= 2.0;
                        }
                        return sum;
                    }
                    
                    void main() {
                        float y = normalize(vWorldPosition).y;
                        float t = time * 0.03; 
                        
                        vec3 gradientColor;
                        if(y > 0.0) {
                            gradientColor = mix(middleColor, topColor, smoothstep(0.0, 0.8, y));
                        } else {
                            gradientColor = mix(middleColor, bottomColor, smoothstep(0.0, 0.8, -y));
                        }
                        
                        float r = gradientColor.r + sin(t * 0.5 + y * 2.0) * 0.05;
                        float g = gradientColor.g + sin(t * 0.3 + y * 2.0) * 0.05;
                        float b = gradientColor.b + sin(t * 0.7 + y * 2.0) * 0.05;
                        
                        vec2 cloudUv = vUv * 4.0 + vec2(time * 0.005, time * 0.008);
                        float cloudNoise = fbm(cloudUv);
                        
                        vec2 cloudUv2 = vUv * 2.5 + vec2(time * -0.006, time * 0.004);
                        float cloudNoise2 = fbm(cloudUv2) * 0.5;
                        
                        float clouds = smoothstep(0.5, 0.65, cloudNoise + cloudNoise2);
                        clouds *= smoothstep(0.3, 0.0, abs(y));
                        
                        vec3 finalColor = mix(vec3(r,g,b), cloudColor, clouds * 0.25); 
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.BackSide,
                fog: false 
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            const starsGeometry = new THREE.BufferGeometry();
            const starCount = 5000; 
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const colors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const radius = 400 + Math.random() * 600; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                sizes[i] = Math.random() * 1.5 + 0.5; 
                
                if (Math.random() > 0.9) { 
                    const hue = Math.random();
                    const c = new THREE.Color();
                    c.setHSL(hue, 0.7 + Math.random() * 0.2, 0.7 + Math.random() * 0.2);
                    colors[i3] = c.r; colors[i3 + 1] = c.g; colors[i3 + 2] = c.b;
                } else {
                    const brightness = 0.8 + Math.random() * 0.2;
                    colors[i3] = brightness; colors[i3 + 1] = brightness; colors[i3 + 2] = brightness;
                }
            }
            
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starsMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    uniform float time;
                    uniform float pixelRatio;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float t = time * 1.5;
                        float twinkle = sin(t + position.x * 0.1 + position.y * 0.08 + position.z * 0.05) * 0.4 + 0.6;
                        float dist = length(mvPosition.xyz);
                        float sizeMod = size * twinkle * pixelRatio * (1500.0 / dist); 
                        gl_PointSize = max(1.0, sizeMod); 
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    uniform float time; // Added time uniform to fragment shader
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        float softness = smoothstep(0.5, 0.4, dist);
                        float glow = exp(-dist * 3.0) * 0.4 + softness * 0.6;
                        gl_FragColor = vec4(vColor, softness * glow * (sin(dist * 5.0 + time * 2.0) * 0.1 + 0.9) ); 
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                fog: false
            });
            
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            const nebulaCount = 15; 
            const nebulae = [];
            
            for(let i = 0; i < nebulaCount; i++) {
                const nebSize = 100 + Math.random() * 200; 
                const planeCount = 2 + Math.floor(Math.random() * 2); 
                const nebulaGroup = new THREE.Group();
                
                for(let j = 0; j < planeCount; j++) {
                    const nebulaGeometry = new THREE.PlaneGeometry(nebSize, nebSize, 1, 1);
                    const hue = Math.random(); 
                    const saturation = 0.3 + Math.random() * 0.3;
                    const lightness = 0.2 + Math.random() * 0.2;
                    const c = new THREE.Color().setHSL(hue, saturation, lightness);
                    
                    const nebulaMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            baseColor: { value: c },
                            opacity: { value: 0.02 + Math.random() * 0.04 } 
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 baseColor;
                            uniform float opacity;
                            varying vec2 vUv;
                            
                            float hash(vec2 p) { float h = dot(p,vec2(127.1,311.7)); return fract(sin(h)*43758.5453123); }
                            float noise(vec2 p) {
                                vec2 i = floor(p); vec2 f = fract(p); vec2 u = f*f*(3.0-2.0*f);
                                return mix(mix(hash(i+vec2(0.,0.)), hash(i+vec2(1.,0.)),u.x),
                                            mix(hash(i+vec2(0.,1.)), hash(i+vec2(1.,1.)),u.x),u.y);
                            }
                            float fbm(vec2 p) {
                                float sum = 0.0; float amp = 0.5; float freq = 1.0;
                                for(int i=0; i<6; i++) { 
                                    sum += noise(p*freq)*amp; amp*=0.5; freq*=2.0;
                                }
                                return sum;
                            }
                            void main() {
                                vec2 uv = vUv * 2.0 - 1.0; 
                                float t = time * 0.02 + opacity * 10.0; 
                                vec2 distortedUv = uv;
                                distortedUv.x += sin(uv.y * 2.5 + t) * 0.15;
                                distortedUv.y += cos(uv.x * 2.0 - t) * 0.15;
                                float edge = length(uv);
                                float falloff = smoothstep(1.0, 0.3, edge); 
                                float pattern = fbm(distortedUv * 1.5 + vec2(t*0.1, -t*0.12)); 
                                pattern = smoothstep(0.2, 0.7, pattern) * falloff;
                                float finalOpacity = pattern * opacity * (sin(time * 0.1 + uv.x * 2.0) * 0.2 + 0.8); 
                                vec3 color = baseColor + vec3(pattern * 0.1, pattern * 0.05, sin(t*0.5)*0.05);
                                gl_FragColor = vec4(clamp(color,0.0,1.0), finalOpacity);
                            }
                        `,
                        transparent: true, blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide, depthWrite: false, fog: false
                    });
                    
                    const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                    nebula.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    nebulaGroup.add(nebula);
                }
                
                const distance = 600 + Math.random() * 800; 
                const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1);
                nebulaGroup.position.set(distance*Math.sin(phi)*Math.cos(theta), distance*Math.sin(phi)*Math.sin(theta), distance*Math.cos(phi));
                nebulaGroup.rotation.set(Math.random()*Math.PI*2, Math.random()*Math.PI*2, Math.random()*Math.PI*2);
                
                nebulaGroup.userData = {
                    rotationSpeed: { x:(Math.random()-0.5)*0.0003, y:(Math.random()-0.5)*0.0003, z:(Math.random()-0.5)*0.0003 },
                    baseTimeOffset: Math.random() * 1000 
                };
                
                scene.add(nebulaGroup);
                nebulae.push(nebulaGroup);
            }
            
            return { sky, stars, nebulae };
        }
        
        const environment = createEnvironment();

        scene.fog = new THREE.FogExp2(0x3080ab, 0.008); 
        
        function updateFogColor(time) {
            const cameraHeight = camera.position.y;
            const normalizedHeight = Math.min(Math.max(cameraHeight / 40, 0), 1); 
            
            const bottomFogColor = new THREE.Color(CONFIG.WAVE_MODE === 'fractals' ? 0x401050 : 0x60207c); 
            const middleFogColor = new THREE.Color(0x20508b);
            const topFogColor = new THREE.Color(0x10205c);
            
            const fogColor = new THREE.Color();
            if (normalizedHeight < 0.5) {
                fogColor.lerpColors(bottomFogColor, middleFogColor, normalizedHeight * 2);
            } else {
                fogColor.lerpColors(middleFogColor, topFogColor, (normalizedHeight - 0.5) * 2);
            }
            
            const timeShiftR = Math.sin(time * 0.05) * 0.05;
            const timeShiftG = Math.cos(time * 0.03) * 0.03;
            const timeShiftB = Math.sin(time * 0.07) * 0.04;
            
            fogColor.r = Math.max(0, Math.min(1, fogColor.r + timeShiftR)); // Clamped
            fogColor.g = Math.max(0, Math.min(1, fogColor.g + timeShiftG)); // Clamped
            fogColor.b = Math.max(0, Math.min(1, fogColor.b + timeShiftB)); // Clamped
            
            if (scene.fog) scene.fog.color.copy(fogColor);
            return fogColor;
        }

        // Touch and mouse interaction
        const mouse = new THREE.Vector2(0, 0); // For camera movement
        let interactionPoints = []; 
        const MAX_INTERACTION_POINTS = 5; 
        const INTERACTION_POINT_LIFESPAN = 2000; // ms

        function updateInteractionPoint(x, y, identifier, isPrimary = false) {
            const rect = renderer.domElement.getBoundingClientRect();
            const normalizedX = ((x - rect.left) / rect.width) * 2 - 1;
            const normalizedY = -((y - rect.top) / rect.height) * 2 + 1;

            if (isPrimary) {
                mouse.x = normalizedX;
                mouse.y = normalizedY;
            }

            let existingPoint = interactionPoints.find(p => p.id === identifier);
            if (existingPoint) {
                existingPoint.position.x = normalizedX;
                existingPoint.position.y = normalizedY;
                existingPoint.strength = 1.0; 
                existingPoint.lastUpdate = Date.now();
                existingPoint.dx = (normalizedX - existingPoint.prevPosition.x) * 50; 
                existingPoint.dy = (normalizedY - existingPoint.prevPosition.y) * 50;
                existingPoint.prevPosition.copy(existingPoint.position);
            } else {
                if (interactionPoints.length < MAX_INTERACTION_POINTS) {
                    interactionPoints.push({
                        id: identifier,
                        position: new THREE.Vector2(normalizedX, normalizedY),
                        prevPosition: new THREE.Vector2(normalizedX, normalizedY),
                        strength: 1.0,
                        lastUpdate: Date.now(),
                        dx:0, dy:0,
                        isNew: true, 
                        startTime: Date.now() // For ripple effect timing
                    });
                }
            }
        }

        function decayInteractionPoints() {
            const now = Date.now();
            interactionPoints = interactionPoints.filter(p => {
                const age = now - p.lastUpdate;
                // For ripple mode, let strength decay based on age from start, not last update
                if (CONFIG.WAVE_MODE === 'ripple') {
                     const totalAge = now - p.startTime;
                     p.strength = Math.max(0, 1.0 - (totalAge / INTERACTION_POINT_LIFESPAN));
                     return totalAge <= INTERACTION_POINT_LIFESPAN;
                } else {
                    // For other modes, remove if not updated recently (less aggressive decay)
                    if (age > INTERACTION_POINT_LIFESPAN / 2) { // Shorter lifespan if not actively moved
                        p.strength = Math.max(0, 1.0 - (age / (INTERACTION_POINT_LIFESPAN / 2) ) );
                    }
                     return age <= INTERACTION_POINT_LIFESPAN;
                }
            });
            interactionPoints.forEach(p => p.isNew = false);
        }

        // Particle System
        let particlesMesh;
        let particleMaterial;
        const dummy = new THREE.Object3D(); // For instanced mesh updates

        const particleVertexShader = `
            uniform float time;
            uniform float waveIntensity;
            uniform float waveSpeed;
            uniform float particleSize;
            uniform float colorShiftSpeed;
            uniform vec2 mousePos; // Normalized mouse position
            uniform float mouseInfluence;
            uniform int waveMode; // 0: wave, 1: ripple, 2: fractals

            attribute vec3 initialPosition; // Store initial grid position
            attribute float randomFactor;   // Per-particle random value

            varying float vElevation;
            varying vec3 vColor;

            // Simplex noise functions (from web)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; 
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
            
            uniform vec3 interactionPointsPos[${MAX_INTERACTION_POINTS}];
            uniform float interactionPointsStrength[${MAX_INTERACTION_POINTS}];
            uniform float interactionPointsAge[${MAX_INTERACTION_POINTS}]; // Normalized age 0-1
            uniform int activeInteractionPoints;


            void main() {
                vec3 pos = initialPosition;
                float finalWaveIntensity = waveIntensity;
                float elevation = 0.0;

                if (waveMode == 0) { // Wave mode
                    elevation = sin(pos.x * 0.3 + time * waveSpeed + randomFactor * 0.5) * finalWaveIntensity;
                    elevation += cos(pos.z * 0.2 + time * waveSpeed * 0.7 + randomFactor * 0.8) * finalWaveIntensity * 0.7;
                    
                    // Mouse influence as a depression/elevation
                    float distToMouse = distance(vec2(pos.x, pos.z), vec2(mousePos.x * 20.0, mousePos.y * 20.0)); // Scale mousePos
                    float mouseEffect = smoothstep(mouseInfluence, 0.0, distToMouse) * finalWaveIntensity * 2.0 * (sin(time*waveSpeed*2.0)+0.5);
                    elevation -= mouseEffect;

                } else if (waveMode == 1) { // Ripple mode
                    for (int i = 0; i < ${MAX_INTERACTION_POINTS}; ++i) {
                        if (i < activeInteractionPoints && interactionPointsStrength[i] > 0.0) {
                            vec2 pointPos = vec2(interactionPointsPos[i].x * 20.0, interactionPointsPos[i].y * 20.0); // Scale to world
                            float distToPoint = distance(vec2(pos.x, pos.z), pointPos);
                            float rippleRadius = interactionPointsAge[i] * mouseInfluence * 1.5; // Ripple expands with age
                            float rippleWidth = mouseInfluence * 0.3;
                            
                            float ripple = smoothstep(0.0, rippleWidth, distToPoint - rippleRadius) * smoothstep(rippleWidth, 0.0, distToPoint - (rippleRadius + rippleWidth));
                            
                            if (distToPoint < rippleRadius + rippleWidth * 2.0) { // only affect near ripple
                                elevation += sin(distToPoint * 0.5 - time * waveSpeed * 3.0) * finalWaveIntensity * 1.5 * interactionPointsStrength[i] * ripple;
                            }
                        }
                    }
                } else if (waveMode == 2) { // Fractals mode
                    float noiseFactor = snoise(vec3(pos.x * 0.1, pos.z * 0.1, time * waveSpeed * 0.2 + randomFactor)) * finalWaveIntensity * 2.5;
                    noiseFactor += snoise(vec3(pos.x * 0.3 + time*0.1, pos.z * 0.3 - time*0.1, time * waveSpeed * 0.5 + randomFactor)) * finalWaveIntensity * 1.0;
                    elevation = noiseFactor;
                }
                
                pos.y = elevation;
                vElevation = elevation;

                // Color based on elevation and time
                float hue = mod( (elevation * 0.1) + (time * colorShiftSpeed) + (initialPosition.x + initialPosition.z) * 0.01 + randomFactor * 0.1, 1.0);
                float saturation = 0.6 + sin(time * colorShiftSpeed * 5.0 + initialPosition.x * 0.05) * 0.2 + randomFactor * 0.1;
                float lightness = 0.4 + (elevation / finalWaveIntensity) * 0.2 + sin(time * colorShiftSpeed * 3.0 + initialPosition.z * 0.03) * 0.1;
                
                vColor.r = hue; // Will be converted from HSL in fragment shader
                vColor.g = clamp(saturation, 0.3, 0.9);
                vColor.b = clamp(lightness, 0.2, 0.7);


                vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                gl_PointSize = particleSize * (300.0 / -mvPosition.z) * (1.0 + randomFactor * 0.5); // Size attenuation
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            varying float vElevation;
            varying vec3 vColor; // R: hue, G: saturation, B: lightness

            // HSL to RGB conversion
            vec3 hsl2rgb(vec3 c) {
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);
                return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
            }

            void main() {
                vec3 finalColor = hsl2rgb(vColor);
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard; // Make points circular

                float alpha = smoothstep(0.5, 0.4, dist); // Softer edges
                alpha *= (0.6 + vElevation * 0.1); // Brighter for higher elevation

                gl_FragColor = vec4(finalColor, clamp(alpha, 0.1, 0.9));
            }
        `;

        function createParticles() {
            if (particlesMesh) {
                scene.remove(particlesMesh);
                if (particlesMesh.geometry) particlesMesh.geometry.dispose();
                // Material is reused or reconfigured
            }

            const count = CONFIG.GRID_SIZE * CONFIG.GRID_SIZE;
            const particleGeometry = new THREE.PlaneGeometry(1, 1); // Base geometry for each instance

            const instancedGeometry = new THREE.InstancedBufferGeometry();
            instancedGeometry.index = particleGeometry.index;
            instancedGeometry.attributes.position = particleGeometry.attributes.position;
            instancedGeometry.attributes.uv = particleGeometry.attributes.uv;

            const initialPositions = new Float32Array(count * 3);
            const randomFactors = new Float32Array(count);

            let idx = 0;
            const offset = (CONFIG.GRID_SIZE * CONFIG.SPACING) / 2;
            for (let i = 0; i < CONFIG.GRID_SIZE; i++) {
                for (let j = 0; j < CONFIG.GRID_SIZE; j++) {
                    initialPositions[idx * 3 + 0] = (i * CONFIG.SPACING) - offset;
                    initialPositions[idx * 3 + 1] = 0; // Initial Y position
                    initialPositions[idx * 3 + 2] = (j * CONFIG.SPACING) - offset;
                    randomFactors[idx] = Math.random();
                    idx++;
                }
            }
            instancedGeometry.setAttribute('initialPosition', new THREE.InstancedBufferAttribute(initialPositions, 3));
            instancedGeometry.setAttribute('randomFactor', new THREE.InstancedBufferAttribute(randomFactors, 1));


            if (!particleMaterial) {
                particleMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        waveIntensity: { value: CONFIG.WAVE_INTENSITY },
                        waveSpeed: { value: CONFIG.WAVE_SPEED },
                        particleSize: { value: CONFIG.PARTICLE_SIZE },
                        colorShiftSpeed: { value: CONFIG.COLOR_SHIFT_SPEED },
                        mousePos: { value: new THREE.Vector2(0,0) },
                        mouseInfluence: { value: CONFIG.MOUSE_INFLUENCE },
                        waveMode: { value: (CONFIG.WAVE_MODE === 'wave' ? 0 : (CONFIG.WAVE_MODE === 'ripple' ? 1 : 2)) },
                        interactionPointsPos: { value: new Array(MAX_INTERACTION_POINTS).fill(new THREE.Vector3()) },
                        interactionPointsStrength: { value: new Array(MAX_INTERACTION_POINTS).fill(0.0) },
                        interactionPointsAge: { value: new Array(MAX_INTERACTION_POINTS).fill(0.0) },
                        activeInteractionPoints: { value: 0 }
                    },
                    vertexShader: particleVertexShader,
                    fragmentShader: particleFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending, // Can be NormalBlending too
                    depthWrite: false // Important for additive blending
                });
            } else {
                 // Update existing material uniforms if needed after a reset or mode change
                particleMaterial.uniforms.waveIntensity.value = CONFIG.WAVE_INTENSITY;
                particleMaterial.uniforms.waveSpeed.value = CONFIG.WAVE_SPEED;
                particleMaterial.uniforms.particleSize.value = CONFIG.PARTICLE_SIZE;
                particleMaterial.uniforms.colorShiftSpeed.value = CONFIG.COLOR_SHIFT_SPEED;
                particleMaterial.uniforms.mouseInfluence.value = CONFIG.MOUSE_INFLUENCE;
                particleMaterial.uniforms.waveMode.value = (CONFIG.WAVE_MODE === 'wave' ? 0 : (CONFIG.WAVE_MODE === 'ripple' ? 1 : 2));
            }

            // Using THREE.Points for particle system with gl_PointSize
            // If you want to use InstancedMesh with PlaneGeometry, you'd set up instanceMatrix
            particlesMesh = new THREE.Points(instancedGeometry, particleMaterial);
            // If using InstancedMesh for planes:
            // particlesMesh = new THREE.InstancedMesh(particleGeometry, particleMaterial, count);
            // particlesMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // Important for performance
            
            // For THREE.Points with custom attributes, no need to update instanceMatrix in loop like below
            // For InstancedMesh, you would do:
            // let instIdx = 0;
            // for (let i = 0; i < CONFIG.GRID_SIZE; i++) {
            //     for (let j = 0; j < CONFIG.GRID_SIZE; j++) {
            //         dummy.position.set(
            //             (i * CONFIG.SPACING) - offset,
            //             0, // Y will be handled in shader or updated here if not in shader
            //             (j * CONFIG.SPACING) - offset
            //         );
            //         dummy.updateMatrix();
            //         particlesMesh.setMatrixAt(instIdx++, dummy.matrix);
            //     }
            // }
            // particlesMesh.instanceMatrix.needsUpdate = true;

            scene.add(particlesMesh);
        }
        
        function updateParticles(time) {
            if (!particlesMesh || !particleMaterial) return;

            particleMaterial.uniforms.time.value = time;
            particleMaterial.uniforms.mousePos.value.copy(mouse); // Send normalized mouse directly

            const currentInteractionPos = [];
            const currentInteractionStrength = [];
            const currentInteractionAge = [];
            const now = Date.now();

            for(let i=0; i<MAX_INTERACTION_POINTS; i++) {
                if (i < interactionPoints.length) {
                    currentInteractionPos[i] = new THREE.Vector3(interactionPoints[i].position.x, interactionPoints[i].position.y, 0);
                    currentInteractionStrength[i] = interactionPoints[i].strength;
                    currentInteractionAge[i] = Math.min(1.0, (now - interactionPoints[i].startTime) / INTERACTION_POINT_LIFESPAN);
                } else {
                    currentInteractionPos[i] = new THREE.Vector3(); // Zero out unused
                    currentInteractionStrength[i] = 0.0;
                    currentInteractionAge[i] = 0.0;
                }
            }
            particleMaterial.uniforms.interactionPointsPos.value = currentInteractionPos;
            particleMaterial.uniforms.interactionPointsStrength.value = currentInteractionStrength;
            particleMaterial.uniforms.interactionPointsAge.value = currentInteractionAge;
            particleMaterial.uniforms.activeInteractionPoints.value = interactionPoints.length;
        }


        // Camera
        camera.position.set(0, 10, 25); // Adjusted initial camera position
        camera.lookAt(scene.position);

        const clock = new THREE.Clock();

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // Update environment
            if (environment.sky) environment.sky.material.uniforms.time.value = elapsedTime;
            if (environment.stars) environment.stars.material.uniforms.time.value = elapsedTime;
            environment.nebulae.forEach(nebulaGroup => {
                nebulaGroup.rotation.x += nebulaGroup.userData.rotationSpeed.x;
                nebulaGroup.rotation.y += nebulaGroup.userData.rotationSpeed.y;
                nebulaGroup.rotation.z += nebulaGroup.userData.rotationSpeed.z;
                nebulaGroup.children.forEach(nebulaMesh => {
                    if (nebulaMesh.material.uniforms && nebulaMesh.material.uniforms.time) {
                         nebulaMesh.material.uniforms.time.value = elapsedTime + nebulaGroup.userData.baseTimeOffset;
                    }
                });
            });

            updateFogColor(elapsedTime);
            decayInteractionPoints();
            updateParticles(elapsedTime);


            // Camera movement based on mouse (subtle parallax)
            if (CONFIG.CAMERA_MOTION_INTENSITY > 0) {
                const targetCameraX = mouse.x * 2 * CONFIG.CAMERA_MOTION_INTENSITY;
                const targetCameraY = 10 - (mouse.y * 1.5 * CONFIG.CAMERA_MOTION_INTENSITY); // Adjust base height and mouse influence
                camera.position.x += (targetCameraX - camera.position.x) * 0.05;
                camera.position.y += (targetCameraY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0); // Look at the center of the particle field
            }


            renderer.render(scene, camera);
        }

        // Event Listeners
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(particleMaterial) particleMaterial.uniforms.pixelRatio.value = renderer.getPixelRatio(); // if stars shader uses it
            if(environment.stars && environment.stars.material.uniforms.pixelRatio) {
                 environment.stars.material.uniforms.pixelRatio.value = renderer.getPixelRatio();
            }
        }
        window.addEventListener('resize', onWindowResize);

        function onPointerMove(event) {
            const isPrimary = event.isPrimary === undefined ? true : event.isPrimary; // Handle mouse (isPrimary undefined)
            updateInteractionPoint(event.clientX, event.clientY, event.pointerId || 'mouse', isPrimary);
        }
        window.addEventListener('pointermove', onPointerMove);
        
        // Optional: More discrete interactions for ripple mode on click/tap
        function onPointerDown(event) {
            updateInteractionPoint(event.clientX, event.clientY, event.pointerId || 'mouse_down', true); // Treat as primary for this event
            // For ripple, a new point is created or an existing one is refreshed
             let point = interactionPoints.find(p => p.id === (event.pointerId || 'mouse_down'));
             if (point) {
                 point.startTime = Date.now(); // Reset ripple age on new press
                 point.strength = 1.0;
                 point.lastUpdate = Date.now();
             }
        }
        window.addEventListener('pointerdown', onPointerDown);


        // UI Controls Setup
        function setupControls() {
            document.getElementById('wave-intensity').addEventListener('input', (e) => {
                CONFIG.WAVE_INTENSITY = parseFloat(e.target.value);
                if (particleMaterial) particleMaterial.uniforms.waveIntensity.value = CONFIG.WAVE_INTENSITY;
            });
            document.getElementById('particle-size').addEventListener('input', (e) => {
                CONFIG.PARTICLE_SIZE = parseFloat(e.target.value);
                 if (particleMaterial) particleMaterial.uniforms.particleSize.value = CONFIG.PARTICLE_SIZE;
            });
            document.getElementById('color-speed').addEventListener('input', (e) => {
                CONFIG.COLOR_SHIFT_SPEED = parseFloat(e.target.value);
                 if (particleMaterial) particleMaterial.uniforms.colorShiftSpeed.value = CONFIG.COLOR_SHIFT_SPEED;
            });
            document.getElementById('camera-motion').addEventListener('input', (e) => {
                CONFIG.CAMERA_MOTION_INTENSITY = parseFloat(e.target.value);
            });

            const modeButtons = document.querySelectorAll('.mode-btn');
            const modeDisplay = document.getElementById('mode-display');
            modeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    modeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    if (button.id === 'mode-wave') CONFIG.WAVE_MODE = 'wave';
                    else if (button.id === 'mode-ripple') CONFIG.WAVE_MODE = 'ripple';
                    else if (button.id === 'mode-fractals') CONFIG.WAVE_MODE = 'fractals';
                    
                    if (particleMaterial) particleMaterial.uniforms.waveMode.value = (CONFIG.WAVE_MODE === 'wave' ? 0 : (CONFIG.WAVE_MODE === 'ripple' ? 1 : 2));
                    modeDisplay.textContent = CONFIG.WAVE_MODE.charAt(0).toUpperCase() + CONFIG.WAVE_MODE.slice(1);
                });
            });

            const audioToggle = document.getElementById('audio-toggle');
            audioToggle.addEventListener('click', () => {
                if (!audioContext) initAudio(); // Initialize on first click if not ready
                if (audioContext && audioContext.state === 'suspended') { // Needed for autoplay policies
                    audioContext.resume();
                }
                CONFIG.AUDIO_ENABLED = !CONFIG.AUDIO_ENABLED;
                updateAudioButton();
            });

            document.getElementById('audio-volume').addEventListener('input', (e) => {
                CONFIG.AUDIO_VOLUME = parseFloat(e.target.value);
                if (CONFIG.AUDIO_ENABLED && gainNode && audioContext) {
                    gainNode.gain.setTargetAtTime(CONFIG.AUDIO_VOLUME, audioContext.currentTime, 0.1);
                }
            });
            
            document.getElementById('reset-btn').addEventListener('click', () => {
                CONFIG = { ...DEFAULT_CONFIG };
                // Update UI elements to reflect default values
                document.getElementById('wave-intensity').value = CONFIG.WAVE_INTENSITY;
                document.getElementById('particle-size').value = CONFIG.PARTICLE_SIZE;
                document.getElementById('color-speed').value = CONFIG.COLOR_SHIFT_SPEED;
                document.getElementById('camera-motion').value = CONFIG.CAMERA_MOTION_INTENSITY;
                document.getElementById('audio-volume').value = CONFIG.AUDIO_VOLUME;
                
                modeButtons.forEach(btn => btn.classList.remove('active'));
                document.getElementById(`mode-${CONFIG.WAVE_MODE}`).classList.add('active');
                modeDisplay.textContent = CONFIG.WAVE_MODE.charAt(0).toUpperCase() + CONFIG.WAVE_MODE.slice(1);

                // Update material uniforms
                if (particleMaterial) {
                    particleMaterial.uniforms.waveIntensity.value = CONFIG.WAVE_INTENSITY;
                    particleMaterial.uniforms.particleSize.value = CONFIG.PARTICLE_SIZE;
                    particleMaterial.uniforms.colorShiftSpeed.value = CONFIG.COLOR_SHIFT_SPEED;
                    particleMaterial.uniforms.waveMode.value = (CONFIG.WAVE_MODE === 'wave' ? 0 : (CONFIG.WAVE_MODE === 'ripple' ? 1 : 2));
                }
                updateAudioButton(); // Reflects potential change in AUDIO_ENABLED and volume
            });

            const fullscreenBtn = document.getElementById('fullscreen-btn');
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            });
        }

        // Initialization
        function init() {
            // No external assets to load via manager for basic setup, so we can "complete" it.
            // If you add textures later, register them with loadingManager.
            // For now, this makes the loading screen disappear after a short delay.
            if(loadingManager.onProgress) loadingManager.onProgress('', 1, 1); // Simulate completion
            if(loadingManager.onLoad) loadingManager.onLoad();


            initAudio(); // Initialize audio (can be deferred to first interaction if preferred)
            createParticles();
            setupControls();
            animate();
        }

        init();

    </script>
</body>
</html>
