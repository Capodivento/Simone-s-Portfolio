<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Interactive Wave Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Keep the black background */
            color: white; /* For info text */
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: Arial, sans-serif;
            pointer-events: none;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="info">Move your mouse to interact with the particles</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Configuration ---
        const CONFIG = {
            GRID_SIZE: 80,      // Increased for better visual density with points
            SPACING: 0.4,
            WAVE_SPEED: 0.5,
            MOUSE_INFLUENCE_RADIUS: 8.0, // Renamed for clarity
            MOUSE_EFFECT_STRENGTH: 2.5,  // How much mouse pushes particles
            PARTICLE_BASE_SIZE: 175.0,   // ADJUSTED FOR VISIBILITY (was 30.0, resulting in ~0.85px particles)
                                         // Now aims for ~5px particles at grid center with CAMERA_Z = 35
            COLOR_SHIFT_SPEED: 0.001,
            CAMERA_Z: 35,
            SCENE_ROTATION_SPEED: 0.1,
            SCENE_ROTATION_AMOUNT: 0.1
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Mouse Interaction ---
        const mouse = new THREE.Vector2(-10000, -10000); // Initialize far off-screen
        const normalizedMouse = new THREE.Vector2(-10000,-10000); // For direct shader use if needed
        
        window.addEventListener('mousemove', (event) => {
            // For projecting mouse onto a plane at Z=0 from camera's perspective
            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            vec.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1,
                0.5 // unproject from the center of the frustum
            );
            vec.unproject(camera); // Unproject the vector
            vec.sub(camera.position).normalize();
            const distance = -camera.position.z / vec.z; // Distance to the Z=0 plane
            pos.copy(camera.position).add(vec.multiplyScalar(distance));
            mouse.set(pos.x, pos.y); // Store world coordinates on Z=0 plane

            // also store normalized screen coordinates if needed elsewhere
            normalizedMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            normalizedMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mouseout', () => {
            mouse.set(-10000, -10000); // Move mouse influence far away
            normalizedMouse.set(-10000, -10000);
        });


        // --- Particle Shaders ---
        const particleVertexShader = `
            attribute vec3 initialPosition;
            attribute float randomOffset;

            uniform float uTime;
            uniform vec2 uMouse; // World coordinates on Z=0 plane
            uniform float uWaveSpeed;
            uniform float uMouseInfluenceRadius;
            uniform float uMouseEffectStrength;
            uniform float uParticleBaseSize;

            varying float vElevation;
            varying float vMouseEffect;
            varying vec3 vInitialPosition;


            void main() {
                vInitialPosition = initialPosition;
                float dx = uMouse.x - initialPosition.x;
                float dy = uMouse.y - initialPosition.z; // Mouse Y influences Z in this context
                float distanceToMouse = sqrt(dx * dx + dy * dy);
                
                vMouseEffect = smoothstep(uMouseInfluenceRadius, 0.0, distanceToMouse);

                float distFromCenter = length(initialPosition.xz);

                float waveHeight = sin(uTime * uWaveSpeed + distFromCenter * 0.5 + randomOffset) * 0.5;
                waveHeight += sin(uTime * uWaveSpeed * 0.5 - distFromCenter * 0.3 + randomOffset) * 0.3;
                
                vec3 newPosition = initialPosition;
                newPosition.y = waveHeight + vMouseEffect * uMouseEffectStrength;
                vElevation = newPosition.y;

                vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
                
                // Adjust point size based on distance and a base size
                // The division by -mvPosition.z provides perspective scaling for point size
                gl_PointSize = uParticleBaseSize * (1.0 / -mvPosition.z);
                gl_PointSize *= (1.0 + vMouseEffect * 0.5); // Make particles bigger near mouse

                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform float uTime;
            uniform float uColorShiftSpeed;
            
            varying float vElevation;
            varying float vMouseEffect;
            varying vec3 vInitialPosition;

            // Function to convert HSL to RGB
            vec3 hsl2rgb(vec3 c) {
                vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
                return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
            }

            void main() {
                float dist = length(gl_PointCoord - vec2(0.5)); // Makes points circular
                if (dist > 0.5) discard;

                float distFromCenter = length(vInitialPosition.xz);
                float hue = mod(uTime * uColorShiftSpeed + distFromCenter * 0.02, 1.0);
                float saturation = 0.6 + vMouseEffect * 0.4; // More saturated near mouse
                float lightness = 0.45 + vElevation * 0.1 + vMouseEffect * 0.15;

                vec3 color = hsl2rgb(vec3(hue, clamp(saturation, 0.4, 1.0), clamp(lightness, 0.2, 0.8)));
                
                float alpha = smoothstep(0.5, 0.45 - vMouseEffect * 0.1, dist); // Softer edges, slightly more opaque near mouse

                gl_FragColor = vec4(color, alpha);
            }
        `;

        // --- Create Particles ---
        let particlePoints;
        let particleMaterial;

        function createParticles() {
            if (particlePoints) {
                scene.remove(particlePoints);
                particlePoints.geometry.dispose();
                // Material is updated or reused
            }

            const numParticles = CONFIG.GRID_SIZE * CONFIG.GRID_SIZE;
            const geometry = new THREE.InstancedBufferGeometry();

            // Base attribute for instancing (a single point at origin)
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3)); 

            const initialPositions = new Float32Array(numParticles * 3);
            const randomOffsets = new Float32Array(numParticles);

            for (let i = 0, i3 = 0; i < numParticles; i++, i3 += 3) {
                const x = ( (i % CONFIG.GRID_SIZE) - CONFIG.GRID_SIZE / 2) * CONFIG.SPACING;
                const z = ( Math.floor(i / CONFIG.GRID_SIZE) - CONFIG.GRID_SIZE / 2) * CONFIG.SPACING;
                
                initialPositions[i3 + 0] = x;
                initialPositions[i3 + 1] = 0; // Initial Y position (base height)
                initialPositions[i3 + 2] = z;
                randomOffsets[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('initialPosition', new THREE.InstancedBufferAttribute(initialPositions, 3));
            geometry.setAttribute('randomOffset', new THREE.InstancedBufferAttribute(randomOffsets, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uMouse: { value: mouse }, // Pass the world-space mouse position
                    uWaveSpeed: { value: CONFIG.WAVE_SPEED },
                    uMouseInfluenceRadius: { value: CONFIG.MOUSE_INFLUENCE_RADIUS },
                    uMouseEffectStrength: { value: CONFIG.MOUSE_EFFECT_STRENGTH },
                    uParticleBaseSize: { value: CONFIG.PARTICLE_BASE_SIZE },
                    uColorShiftSpeed: { value: CONFIG.COLOR_SHIFT_SPEED }
                },
                vertexShader: particleVertexShader,
                fragmentShader: particleFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending, // Or THREE.NormalBlending for different effect
                depthWrite: false // Often good for transparent particles
            });

            particlePoints = new THREE.Points(geometry, particleMaterial);
            scene.add(particlePoints);
        }
        
        createParticles(); // Initial creation

        // --- Camera ---
        camera.position.set(0, 18, CONFIG.CAMERA_Z); // Adjusted Y for better view
        camera.lookAt(0, 0, 0);

        // --- Animation ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            if (particleMaterial) {
                particleMaterial.uniforms.uTime.value = elapsedTime;
                particleMaterial.uniforms.uMouse.value.copy(mouse); // Ensure mouse uniform is updated
            }
            
            // Rotate scene slightly
            scene.rotation.y = Math.sin(elapsedTime * CONFIG.SCENE_ROTATION_SPEED) * CONFIG.SCENE_ROTATION_AMOUNT;
            
            renderer.render(scene, camera);
        }

        // --- Handle window resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Note: If uParticleBaseSize was dependent on screen height for specific pixel sizing,
            // you might need to update it here too, but the current formula aims for perspective-correct world size.
        });

        // Start animation
        animate();
    </script>
</body>
</html>
