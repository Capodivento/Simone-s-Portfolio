<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Interactive Wave Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Black background */
            color: white; /* For info text */
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: Arial, sans-serif;
            pointer-events: none;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="info">Move your mouse to interact with the particles</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- Configuration ---
        const CONFIG = {
            GRID_SIZE: 80,
            SPACING: 0.4,
            WAVE_SPEED: 0.5,
            MOUSE_INFLUENCE_RADIUS: 8.0,
            MOUSE_EFFECT_STRENGTH: 2.5,
            PARTICLE_BASE_SIZE: 175.0,   // Adjusted for visibility (was 30.0)
            COLOR_SHIFT_SPEED: 0.001,
            CAMERA_Z: 35,
            SCENE_ROTATION_SPEED: 0.1,
            SCENE_ROTATION_AMOUNT: 0.1
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Mouse Interaction ---
        const mouse = new THREE.Vector2(-10000, -10000); // Initialize far off-screen
        // const normalizedMouse = new THREE.Vector2(-10000,-10000); // Available if needed

        window.addEventListener('mousemove', (event) => {
            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            vec.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1,
                0.5 
            );
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            const distance = -camera.position.z / vec.z;
            pos.copy(camera.position).add(vec.multiplyScalar(distance));
            mouse.set(pos.x, pos.y);

            // normalizedMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            // normalizedMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mouseout', () => {
            mouse.set(-10000, -10000);
            // normalizedMouse.set(-10000, -10000);
        });

        // --- Particle Shaders ---
        const particleVertexShader = `
            attribute vec3 initialPosition;
            attribute float randomOffset;

            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uWaveSpeed;
            uniform float uMouseInfluenceRadius;
            uniform float uMouseEffectStrength;
            uniform float uParticleBaseSize;

            varying float vElevation;
            varying float vMouseEffect;
            varying vec3 vInitialPosition;

            void main() {
                vInitialPosition = initialPosition;
                float dx = uMouse.x - initialPosition.x;
                float dy = uMouse.y - initialPosition.z;
                float distanceToMouse = sqrt(dx * dx + dy * dy);
                
                vMouseEffect = smoothstep(uMouseInfluenceRadius, 0.0, distanceToMouse);

                float distFromCenter = length(initialPosition.xz);

                float waveHeight = sin(uTime * uWaveSpeed + distFromCenter * 0.5 + randomOffset) * 0.5;
                waveHeight += sin(uTime * uWaveSpeed * 0.5 - distFromCenter * 0.3 + randomOffset) * 0.3;
                
                vec3 newPosition = initialPosition;
                newPosition.y = waveHeight + vMouseEffect * uMouseEffectStrength;
                vElevation = newPosition.y;

                vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
                
                gl_PointSize = uParticleBaseSize * (1.0 / -mvPosition.z);
                gl_PointSize *= (1.0 + vMouseEffect * 0.5);

                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform float uTime;
            uniform float uColorShiftSpeed;
            
            varying float vElevation;
            varying float vMouseEffect;
            varying vec3 vInitialPosition;

            vec3 hsl2rgb(vec3 c) {
                vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
                return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
            }

            void main() {
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;

                float distFromCenter = length(vInitialPosition.xz);
                float hue = mod(uTime * uColorShiftSpeed + distFromCenter * 0.02, 1.0);
                float saturation = 0.6 + vMouseEffect * 0.4;
                float lightness = 0.45 + vElevation * 0.1 + vMouseEffect * 0.15;

                vec3 color = hsl2rgb(vec3(hue, clamp(saturation, 0.4, 1.0), clamp(lightness, 0.2, 0.8)));
                
                float alpha = smoothstep(0.5, 0.45 - vMouseEffect * 0.1, dist);

                gl_FragColor = vec4(color, alpha);
            }
        `;

        // --- Create Particles ---
        let particlePoints;
        let particleMaterial;

        function createParticles() {
            if (particlePoints) {
                scene.remove(particlePoints);
                particlePoints.geometry.dispose();
            }

            const numParticles = CONFIG.GRID_SIZE * CONFIG.GRID_SIZE;
            const geometry = new THREE.InstancedBufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3)); 

            const initialPositions = new Float32Array(numParticles * 3);
            const randomOffsets = new Float32Array(numParticles);

            for (let i = 0, i3 = 0; i < numParticles; i++, i3 += 3) {
                const x = ( (i % CONFIG.GRID_SIZE) - CONFIG.GRID_SIZE / 2) * CONFIG.SPACING;
                const z = ( Math.floor(i / CONFIG.GRID_SIZE) - CONFIG.GRID_SIZE / 2) * CONFIG.SPACING;
                
                initialPositions[i3 + 0] = x;
                initialPositions[i3 + 1] = 0;
                initialPositions[i3 + 2] = z;
                randomOffsets[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('initialPosition', new THREE.InstancedBufferAttribute(initialPositions, 3));
            geometry.setAttribute('randomOffset', new THREE.InstancedBufferAttribute(randomOffsets, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uMouse: { value: mouse },
                    uWaveSpeed: { value: CONFIG.WAVE_SPEED },
                    uMouseInfluenceRadius: { value: CONFIG.MOUSE_INFLUENCE_RADIUS },
                    uMouseEffectStrength: { value: CONFIG.MOUSE_EFFECT_STRENGTH },
                    uParticleBaseSize: { value: CONFIG.PARTICLE_BASE_SIZE },
                    uColorShiftSpeed: { value: CONFIG.COLOR_SHIFT_SPEED }
                },
                vertexShader: particleVertexShader,
                fragmentShader: particleFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particlePoints = new THREE.Points(geometry, particleMaterial);
            scene.add(particlePoints);
        }
        
        createParticles();

        // --- Camera ---
        camera.position.set(0, 18, CONFIG.CAMERA_Z);
        camera.lookAt(0, 0, 0);

        // --- Animation ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            if (particleMaterial) {
                particleMaterial.uniforms.uTime.value = elapsedTime;
                particleMaterial.uniforms.uMouse.value.copy(mouse);
            }
            
            scene.rotation.y = Math.sin(elapsedTime * CONFIG.SCENE_ROTATION_SPEED) * CONFIG.SCENE_ROTATION_AMOUNT;
            
            renderer.render(scene, camera);
        }

        // --- Handle window resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
